# -*- coding: utf-8 -*-
"""spellchecker.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10d9jCSuSbZrs-NtEjyeuNUXVOokZout_
"""

pip install symspellpy autocorrect

#!/usr/bin/env python3
"""
Enhanced Core Spell Checker with Autocorrect Fallback (Standalone - Clean Version)
- Primary: SymSpell (symmetric delete, 1-2 edits).
- Fallback: Autocorrect (ML-based, if SymSpell fails).
- Single words OR full sentences (auto-detects).
- Loads built-in English dict + optional legal dict.
- No URLs/networkâ€”fully local/offline.
"""

import sys
import logging
import re
from typing import List, Optional
from symspellpy import SymSpell, Verbosity

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class EnhancedSpellChecker:
    """Core spell checker: SymSpell primary, autocorrect fallback."""

    def __init__(self, sym_spell: Optional[SymSpell] = None, max_edit_distance: int = 2):
        self.sym_spell = sym_spell
        self.max_edit_distance = max_edit_distance
        self.word_pattern = re.compile(r'\b[a-zA-Z]+\b')  # For word extraction
        self.backend = "symspell" if sym_spell else None

        # Fallback to autocorrect if no SymSpell
        if not self.sym_spell:
            try:
                from autocorrect import Speller
                self.autocorrect_spell = Speller(lang='en')
                self.backend = "autocorrect"
                logger.info("Switched to autocorrect fallback")
            except ImportError:
                logger.error("Autocorrect not installed: pip install autocorrect")
                raise RuntimeError("No spell checker available")

    def get_suggestions(self, word: str, max_suggestions: int = 3, verbosity: Verbosity = Verbosity.ALL) -> List[str]:
        """
        Get spelling suggestions for a word.
        - SymSpell: Multiple ranked suggestions.
        - Autocorrect: Single corrected word (if different).
        """
        try:
            if self.backend == "symspell":
                suggestions = self.sym_spell.lookup(
                    word.lower(),
                    verbosity,
                    max_edit_distance=self.max_edit_distance,
                    include_unknown=False
                )

                suggestion_terms = []
                seen = set()

                for suggestion in suggestions:
                    if suggestion.term not in seen and suggestion.term.lower() != word.lower():
                        suggestion_terms.append(suggestion.term)
                        seen.add(suggestion.term)

                        if len(suggestion_terms) >= max_suggestions:
                            break

                return suggestion_terms
            elif self.backend == "autocorrect":
                corrected = self.autocorrect_spell(word)
                if corrected.lower() != word.lower():
                    return [corrected]  # Single suggestion
                return []
        except Exception as e:
            logger.error(f"Error getting suggestions for word '{word}': {e}")
            return []

    def correct_sentence(self, text: str) -> str:
        """
        Correct entire sentence.
        - SymSpell: Word-by-word with case/punctuation preservation.
        - Autocorrect: Direct sentence correction.
        """
        if not text.strip():
            return text

        if self.backend == "symspell":
            # Extract words (lowercase for checking, but preserve original)
            words = self.word_pattern.findall(text)
            corrected_text = text  # Start with original

            for word in set(words):  # Dedup for efficiency
                if len(word) <= 2:  # Skip shorts
                    continue

                suggestions = self.get_suggestions(word, max_suggestions=1, verbosity=Verbosity.CLOSEST)
                if suggestions:  # Top suggestion only
                    best_fix = suggestions[0]
                    # Preserve case: If original capitalized, capitalize fix
                    if word[0].isupper():
                        best_fix = best_fix.capitalize()
                    # Replace in text (case-insensitive match)
                    corrected_text = re.sub(re.escape(word), best_fix, corrected_text, flags=re.IGNORECASE)

            return corrected_text
        elif self.backend == "autocorrect":
            # Direct sentence correction (preserves some case/punctuation)
            return self.autocorrect_spell(text)

def load_symspell(builtin_path: str = None, legal_path: str = "legal_dictionary.txt") -> Optional[SymSpell]:
    """
    Load SymSpell with built-in + legal dicts.
    - Returns SymSpell if successful, else None (triggers autocorrect fallback).
    - No other fallbacks.
    """
    import os  # Local import for function
    sym_spell = SymSpell(max_dictionary_edit_distance=2, prefix_length=7)

    # Load built-in English dict (bundled with symspellpy)
    builtin_loaded = False
    try:
        # Use symspellpy's bundled resource (no manual path needed)
        from importlib.resources import files, as_file
        with as_file(files("symspellpy").joinpath("frequency_dictionary_en_82_765.txt")) as dict_path:
            sym_spell.load_dictionary(str(dict_path), 0, 1)  # Col 0: word, Col 1: freq
            builtin_loaded = True
            logger.info("Built-in English dictionary loaded (82k words)")
    except Exception as e:
        logger.error(f"Failed to load built-in dict: {e}")
        return None  # Trigger autocorrect fallback

    # Load legal dict (local file: word TAB freq or word TAB 1)
    legal_loaded = False
    try:
        if legal_path and os.path.exists(legal_path):
            sym_spell.load_dictionary(legal_path, 0, 1)
            legal_loaded = True
            logger.info(f"Legal dictionary loaded ({sum(1 for _ in open(legal_path))} terms)")
        else:
            logger.warning("Legal dict not foundâ€”skipping (create 'legal_dictionary.txt')")
    except Exception as e:
        logger.warning(f"Failed to load legal dict: {e}")

    if not builtin_loaded:
        return None  # Trigger autocorrect fallback

    logger.info(f"SymSpell ready: Builtin={builtin_loaded}, Legal={legal_loaded}")
    return sym_spell

# Demo/CLI (Enhanced for Sentences)
if __name__ == "__main__":
    # Load SymSpell (or None for fallback)
    sym_spell = load_symspell()

    # Init checker (handles fallback internally)
    try:
        spell_checker = EnhancedSpellChecker(sym_spell)
        print(f"Enhanced Core Spell Checker loaded! (Backend: {spell_checker.backend})")
        print("(Type single words or full sentences; 'quit' to exit)")
    except Exception as e:
        print(f"Init failed: {e}")
        sys.exit(1)

    # Interactive demo
    while True:
        user_input = input("\nInput: ").strip()
        if user_input.lower() == 'quit':
            break
        if not user_input:
            continue

        # Auto-detect: Word (no spaces) vs. Sentence (has spaces)
        if ' ' in user_input:
            print("Mode: Sentence Correction")
            corrected = spell_checker.correct_sentence(user_input)
            print(f"Original:  {user_input}")
            print(f"Corrected: {corrected}")
            print(f"Changes: {'Yes' if corrected != user_input else 'No'}")
        else:
            word = user_input.lower()
            print("Mode: Word Suggestions")
            suggestions = spell_checker.get_suggestions(word, max_suggestions=3)
            print(f"Suggestions for '{word}': {suggestions or 'None (exact or unknown)'}")
            if spell_checker.backend == "symspell":
                lookups = spell_checker.sym_spell.lookup(word, Verbosity.CLOSEST)
                distance = min([s.distance for s in lookups] or [0])
                print(f"Distance: {distance} edits")
            else:
                print("Distance: N/A (autocorrect backend)")

    print("Demo ended! ðŸ˜Ž")